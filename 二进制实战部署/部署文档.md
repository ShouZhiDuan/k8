# K8集群部署文档

## 一、账户信息

- 主机密码

```tex
HY@node.com
```

- 远程连接

```tex
740478454
n5298l
```

## 二、服务器资源分配

| 序号 | 系统   | 主机名                            | IP           | 内存 | 磁盘 | 角色          | 备注         |
| ---- | ------ | --------------------------------- | ------------ | ---- | ---- | ------------- | ------------ |
| 1    | Ubuntu | node-1                            | 210.37.68.73 | 8G   | 1T   | MASTER        | 单角色       |
| 2    | Ubuntu | node-2                            | 210.37.68.74 | 8G   | 1T   | MASTER/WORKER | 多角色       |
| 3    | Ubuntu | node-3                            | 210.37.68.75 | 8G   | 1T   | WORKER        | 单角色       |
| 4    | Ubuntu | node-4                            | 210.37.68.76 | 8G   | 1T   | WORKER        | 单角色       |
| 5    | Ubuntu | node-5                            | 210.37.68.77 | 8G   | 1T   | WORKER        | 单角色       |
| 6    | Ubuntu | node-6                            | 210.37.68.78 | 8G   | 1T   | ETCD/WORKER   | 多角色       |
| 7    | Ubuntu | node-7                            | 210.37.68.79 | 8G   | 1T   | ETCD/WORKER   | 多角色       |
| 8    | Ubuntu | node-8                            | 210.37.68.80 | 8G   | 1T   | ETCD/WORKER   | 多角色       |
| 9    | Ubuntu | node-Standard-PC-i440FX-PIIX-1996 | 210.37.68.72 | 8G   | 1T   | NFS           | 网络文件系统 |
## 三、Kubernetes集群部署

### 1、环境准备

- 1.1 修改主机名（所有机器）

  ```shell
  vi /etc/hostname
  hostname #自定义
  ```

- 1.2 本地域名解析（所有机器）

  ```
  $ vi /etc/hosts
  # <ip> <hostname>
  如下格式：
  210.37.68.73 node-1
  210.37.68.74 node-2
  210.37.68.75 node-3
  210.37.68.76 node-4
  210.37.68.77 node-5
  210.37.68.78 node-6
  210.37.68.79 node-7
  210.37.68.80 node-8
  ```

- 1.3 关闭防火墙、swap分区、selinux、dnsmasq（否则可能导致容器无法解析域名）（所有机器）

  ```shell
  # 关闭防火墙
  $ systemctl stop firewalld && systemctl disable firewalld
  # 关闭swap
  $ swapoff -a && free –h
  # 关闭selinux
  $ setenforce 0
  # 关闭dnsmasq(否则可能导致容器无法解析域名)
  $ service dnsmasq stop && systemctl disable dnsmasq
  ```

- 1.4 配置k8s参数（所有机器）

  ```shell
  # 制作配置文件
  $ cat > /etc/sysctl.d/kubernetes.conf <<EOF
  net.bridge.bridge-nf-call-ip6tables = 1
  net.bridge.bridge-nf-call-iptables = 1
  net.ipv4.ip_nonlocal_bind = 1
  net.ipv4.ip_forward = 1
  vm.swappiness = 0
  vm.overcommit_memory = 1
  EOF
  # 生效文件
  $ sysctl -p /etc/sysctl.d/kubernetes.conf
  ```

- 1.5 配置免密登陆（one of master ）

  ```shell
  # 看看是否已经存在rsa公钥
  $ cat ~/.ssh/id_rsa.pub
  # 如果不存在就创建一个新的
  $ ssh-keygen -t rsa
  # 把id_rsa.pub文件内容copy到其他机器的授权文件中
  $ cat ~/.ssh/id_rsa.pub
  # 在其他节点执行下面命令（所有机器）
  $ echo "<file_content>" >> ~/.ssh/authorized_keys
  ```

- 1.6 k8s软件包下载（one of master）

  ```shell
  # 设定版本号
  $ export VERSION=v1.20.2
  # 下载master节点组件
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-apiserver
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-controller-manager
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-scheduler
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kubectl
  # 下载worker节点组件
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-proxy
  $ wget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kubelet
  # 下载etcd组件
  $ wget https://github.com/etcd-io/etcd/releases/download/v3.4.10/etcd-v3.4.10-linux-amd64.tar.gz
  $ tar -xvf etcd-v3.4.10-linux-amd64.tar.gz
  $ mv etcd-v3.4.10-linux-amd64/etcd* .
  $ rm -fr etcd-v3.4.10-linux-amd64*
  # 统一修改文件权限为可执行
  $ chmod +x kube*
  ```

- 1.7 软件包分发（one of master）

  ```shell
  # 注意涉及到key-value(类似MASTERS=(node-1 node-2))
  # 设置的时候转成bash模式，否则变量输出会有问题。
  
  # 1、master相关组件分发到master节点
  $ MASTERS=(node-1 node-2)
  for instance in ${MASTERS[@]}; do
    scp kube-apiserver kube-controller-manager kube-scheduler kubectl root@${instance}:/usr/local/bin/
  done
  # 2、worker先关组件分发到worker节点
  $ WORKERS=(node-2 node-3 node-4 node-5 node-6 node-7 node-8)
  $ for instance in ${WORKERS[@]}; do
    scp kubelet kube-proxy root@${instance}:/usr/local/bin/
  done
  # 3、etcd组件分发到etcd节点
  $ ETCDS=(node-6 node-7 node-8)
  $ for instance in ${ETCDS[@]}; do
    scp etcd etcdctl root@${instance}:/usr/local/bin/
  done
  ```

### 2、签发证书

- **2.1 安装cfssl（one of master）**

  ```shell
  # 下载
  $ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl
  $ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssljson
  # 修改为可执行权限
  $ chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson
  # 验证
  $ cfssl version
  ```

- **2.2 根证书（one of master）**

  ```shell
  $ cat > ca-config.json <<EOF
  {
    "signing": {
      "default": {
        "expiry": "876000h"
      },
      "profiles": {
        "kubernetes": {
          "usages": ["signing", "key encipherment", "server auth", "client auth"],
          "expiry": "876000h"
        }
      }
    }
  }
  EOF
  
  $ cat > ca-csr.json <<EOF
  {
    "CN": "Kubernetes",
    "key": {
      "algo": "rsa",
      "size": 2048
    },
    "names": [
      {
        "C": "US",
        "L": "Portland",
        "O": "Kubernetes",
        "OU": "CA",
        "ST": "Oregon"
      }
    ]
  }
  EOF
  ```

  `执行`

  ```shell
  # 生成证书和私钥
  $ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
  # 生成完成后会有以下文件（我们最终想要的就是ca-key.pem和ca.pem，一个秘钥，一个证书）
  $ ls
  ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
  ```

- **admin客户端证书（one of master）**

  ```shell
  $ cat > admin-csr.json <<EOF
  {
    "CN": "admin",
    "key": {
      "algo": "rsa",
      "size": 2048
    },
    "names": [
      {
        "C": "CN",
        "ST": "BeiJing",
        "L": "BeiJing",
        "O": "system:masters",
        "OU": "seven"
      }
    ]
  }
  EOF
  ```

  `执行`

  ```shell
  $ cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -profile=kubernetes \
    admin-csr.json | cfssljson -bare admin
  ```

- **kubelet客户端证书（one of master）**

  ```shell
  # 所有worker节点node列表
  $ WORKERS=(node-2 node-3)
  # 所有worker节点IP列表
  $ WORKER_IPS=(10.155.19.64 10.155.19.147)
  
  # 生成所有worker节点的证书配置
  $ for ((i=0;i<${#WORKERS[@]};i++)); do
  cat > ${WORKERS[$i]}-csr.json <<EOF
  {
    "CN": "system:node:${WORKERS[$i]}",
    "key": {
      "algo": "rsa",
      "size": 2048
    },
    "names": [
      {
        "C": "CN",
        "L": "Beijing",
        "O": "system:nodes",
        "OU": "seven",
        "ST": "Beijing"
      }
    ]
  }
  EOF
  cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -hostname=${WORKERS[$i]},${WORKER_IPS[$i]} \
    -profile=kubernetes \
    ${WORKERS[$i]}-csr.json | cfssljson -bare ${WORKERS[$i]}
  done
  ```

- **kube-controller-manager客户端证书**

  ```shell
  $ cat > kube-controller-manager-csr.json <<EOF
  {
      "CN": "system:kube-controller-manager",
      "key": {
          "algo": "rsa",
          "size": 2048
      },
      "names": [
        {
          "C": "CN",
          "ST": "BeiJing",
          "L": "BeiJing",
          "O": "system:kube-controller-manager",
          "OU": "seven"
        }
      ]
  }
  EOF
  ```

  `执行`

  ```shell
  $ cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -profile=kubernetes \
    kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager
  ```

- **kube-proxy客户端证书**

  ```shell
  $ cat > kube-proxy-csr.json <<EOF
  {
    "CN": "system:kube-proxy",
    "key": {
      "algo": "rsa",
      "size": 2048
    },
    "names": [
      {
        "C": "CN",
        "ST": "BeiJing",
        "L": "BeiJing",
        "O": "k8s",
        "OU": "seven"
      }
    ]
  }
  EOF
  ```

  `执行`

  ```shell
  $ cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -profile=kubernetes \
    kube-proxy-csr.json | cfssljson -bare kube-proxy
  ```

- **kube-scheduler客户端证书**

  ```shell
  $ cat > kube-scheduler-csr.json <<EOF
  {
      "CN": "system:kube-scheduler",
      "key": {
          "algo": "rsa",
          "size": 2048
      },
      "names": [
        {
          "C": "CN",
          "ST": "BeiJing",
          "L": "BeiJing",
          "O": "system:kube-scheduler",
          "OU": "seven"
        }
      ]
  }
  EOF
  ```

  `执行`

  ```shell
  $ cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -profile=kubernetes \
    kube-scheduler-csr.json | cfssljson -bare kube-scheduler
  ```

- **kube-apiserver服务端证书**

  ```shell
  $ cat > kubernetes-csr.json <<EOF
  {
    "CN": "kubernetes",
    "key": {
      "algo": "rsa",
      "size": 2048
    },
    "names": [
      {
        "C": "CN",
        "ST": "BeiJing",
        "L": "BeiJing",
        "O": "k8s",
        "OU": "seven"
      }
    ]
  }
  EOF
  ```

  `执行`

  ```shell
  # apiserver的service ip地址（一般是svc网段的第一个ip,如果不理解就直接用这个IP就好了）
  $ KUBERNETES_SVC_IP=10.233.0.1
  # 所有的master和etcd的ip
  # 注意这里一定要将etcd的ip列表加进来否则etcd集群无法验证通过，导致etcd集群无法起来
  $ MASTER_IPS=10.155.19.223,10.155.19.64,10.155.19.147
  # 生成证书
  $ cfssl gencert \
    -ca=ca.pem \
    -ca-key=ca-key.pem \
    -config=ca-config.json \
    -hostname=${KUBERNETES_SVC_IP},${MASTER_IPS},127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local \
    -profile=kubernetes \
    kubernetes-csr.json | cfssljson -bare kubernetes
  ```

  

































